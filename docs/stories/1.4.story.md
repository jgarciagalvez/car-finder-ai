# <!-- Powered by BMAD™ Core -->

# Story 1.4: Schema-Driven HTML Parser

## Status
Done

## Story
**As a** user,
**I want** a parser that reads a `parser-schema.json` file and uses its rules (CSS selectors) to extract structured data from a raw HTML string,
**so that** I can turn unstructured web pages into clean data without hardcoding parsing logic.

## Acceptance Criteria
1. A `parser-schema.json` file is created with hybrid parsing configurations for both search and detail pages.
2. A `ParserService` is created that uses `Cheerio` to load HTML and extract JSON from script tags.
3. The service has a function that takes raw HTML and a site key, auto-detects page type (search/detail), and returns structured data with page type information.
4. The service supports both search results parsing (URLs + basic info) and detail page parsing (complete vehicle data).

## Tasks / Subtasks
- [x] Add Cheerio dependency to API application (AC: 2)
  - [x] Install Cheerio ~1.0.0 in apps/api package
  - [x] Add @types/cheerio for TypeScript support (not needed - Cheerio provides own types)
  - [x] Update package.json with proper dependency versions
- [x] Create parser-schema.json configuration file (AC: 1)
  - [x] Create parser-schema.json in project root with hybrid parsing configurations
  - [x] Define Otomoto.pl JSON extraction paths based on __NEXT_DATA__ structure
  - [x] Define OLX.pl CSS selector fallback structure
  - [x] Include all required Vehicle interface field mappings
- [x] Create ParserService class with hybrid parsing functionality (AC: 2, 3, 4)
  - [x] Implement ParserService class in apps/api/src/services/
  - [x] Add schema loading and validation functionality
  - [x] Implement parseHtml method that accepts HTML, site key, and optional expected page type
  - [x] Add automatic page type detection based on JSON structure analysis
  - [x] Add Otomoto JSON extraction from __NEXT_DATA__ script tag
  - [x] Add CSS selector fallback using Cheerio for other sites
  - [x] Return structured data with detected page type information
- [x] Implement Otomoto-specific JSON parsing with page type detection (Primary Method)
  - [x] Extract and parse __NEXT_DATA__ script tag content
  - [x] Implement auto-detection logic for search vs detail pages
  - [x] Navigate JSON path: props.pageProps.urqlState for search pages
  - [x] Navigate JSON path: props.pageProps.advert for detail pages
  - [x] Handle dynamic query hash keys in urqlState
  - [x] Parse nested stringified JSON in data properties
  - [x] Validate detected page type against expected type (if provided)
- [x] Add data extraction and normalization (Integration)
  - [x] Extract and normalize price data (PLN to EUR conversion)
  - [x] Extract and clean text content (remove HTML, normalize whitespace)
  - [x] Extract and validate image URLs from both JSON and CSS methods
  - [x] Handle missing or malformed data gracefully across both parsing methods
- [x] Add comprehensive testing (Testing Requirements)
  - [x] Create unit tests for ParserService initialization and schema loading
  - [x] Create integration tests with sample Otomoto HTML containing __NEXT_DATA__
  - [x] Test JSON path navigation and dynamic key handling
  - [x] Test CSS selector fallback functionality
  - [x] Test data normalization and type conversion for both methods
- [x] Add service integration and exports (Integration)
  - [x] Export ParserService from apps/api/src/index.ts
  - [x] Create proper TypeScript interfaces for schema structure
  - [x] Add error handling and logging for parsing failures
  - [x] Add fallback logic when JSON parsing fails

## Dev Notes

### Previous Story Insights
From Story 1.3 completion:
- ScraperService successfully implemented with Puppeteer for HTML retrieval
- Comprehensive browser lifecycle management and stealth configurations working
- Rate limiting and respectful delays implemented for ethical scraping
- Integration point established for consuming HTML content in parsing pipeline

### Hybrid Parser Architecture
**Technology:** Cheerio ~1.0.0 - Server-side jQuery implementation for HTML parsing [Source: architecture.md#tech-stack]
**Pattern:** Hybrid schema-driven parser with JSON extraction for Otomoto and CSS fallback [Source: architecture.md#architectural-patterns]
**Configuration:** External parser-schema.json file for both JSON paths and CSS selectors [Source: architecture.md#high-level-architecture-diagram]
**Location:** apps/api - Backend API application handles parsing logic [Source: architecture.md#unified-project-structure]

### Two-Phase Scraping Architecture
**Phase 1 - Search Results:** Extract vehicle URLs and basic metadata from search pages
**Phase 2 - Detail Pages:** Extract complete vehicle information from individual listing pages
**Auto-Detection:** Parser automatically determines page type based on JSON structure analysis

### Otomoto-Specific JSON Parsing Strategy
**Primary Method:** Extract structured data from `<script id="__NEXT_DATA__">` JSON content
**Data Source:** Otomoto embeds all listing data in structured JSON format within the HTML
**Reliability:** Much more reliable than CSS selectors as JSON structure is stable

**Page Type Auto-Detection Logic:**
```typescript
// Detection based on JSON structure
if (pageProps?.advert) return 'detail';           // Has direct advert object
if (pageProps?.urqlState) return 'search';        // Has urqlState with search results
throw new Error('Unknown page type');
```

**Otomoto JSON Navigation Paths:**
- **Search Results:** `props.pageProps.urqlState[dynamicKey].data.advertSearch.edges` (parsed from stringified JSON)
- **Individual Ads:** `props.pageProps.advert` (direct object access)
- **Dynamic Keys:** Handle dynamic query hash keys in urqlState object

**Search Page Data Extraction (Phase 1):**
- **Basic Metadata:** `node.id`, `node.url`, `node.title`, `node.createdAt`
- **Purpose:** Get list of vehicle URLs for detailed scraping
- **Output:** Array of basic vehicle info for Phase 2 processing

**Detail Page Data Extraction (Phase 2):**
- **Complete Vehicle Data:** All fields from Vehicle interface
- **Basic Info:** `id`, `title`, `url`, `price.value`, `price.currency`, `createdAt`
- **Seller Info:** `seller.name`, `seller.id`, `seller.type`, `seller.location.address`
- **Parameters:** `details` array → key-value object using `label`/`value`
- **Equipment:** `equipment` array → categorized arrays using `label`/`values[].label`
- **Images:** `images.photos` array → URL extraction from `url` property

### Parser Schema Structure and Requirements
**Schema File Location:** `parser-schema.json` in project root [Source: architecture.md#high-level-architecture-diagram]
**Schema Purpose:** Support both JSON path extraction (Otomoto) and CSS selectors (fallback) [Source: architecture.md#architectural-patterns]
**Site Support:** Must support both Otomoto.pl and OLX.pl marketplace websites [Source: prd.md#functional-requirements]

**Required Data Extraction Fields:**
Based on Vehicle interface from architecture.md#data-models:
- **Source Metadata:** sourceId, sourceUrl, sourceCreatedAt
- **Raw Content:** sourceTitle, sourceDescriptionHtml, sourceParameters, sourceEquipment, sourcePhotos
- **Processed Data:** title, description, pricePln, priceEur, year, mileage, sellerInfo, photos
- **Seller Information:** SellerInfo interface with name, id, type, location, memberSince

### Technical Requirements and Data Processing
**HTML Processing:**
- Use Cheerio for server-side DOM manipulation and CSS selector application
- Handle JavaScript-rendered content (already rendered by Puppeteer from Story 1.3)
- Graceful handling of missing elements and malformed HTML
- Text normalization (remove HTML tags, normalize whitespace)

**Data Normalization:**
- **Price Conversion:** Convert PLN to EUR using current exchange rate [Source: prd.md#FR4]
- **Text Cleaning:** Remove HTML tags, normalize whitespace, handle encoding issues
- **URL Validation:** Validate and normalize image URLs for photos array
- **Type Conversion:** Ensure proper data types (numbers, dates, strings)

**Error Handling:**
- Graceful handling of missing CSS selectors
- Default values for optional fields
- Logging of parsing failures and data quality issues
- Validation against Vehicle interface requirements

### Project Structure Specifications
**Service Location:** `apps/api/src/services/ParserService.ts` - Backend service for HTML parsing
**Schema Location:** `parser-schema.json` - Root level configuration file
**Integration Point:** Will be consumed by main ingestion pipeline (Story 1.5)
**Package Structure:**
```
apps/api/src/
├── services/
│   ├── ScraperService.ts     (From Story 1.3 - HTML retrieval)
│   └── ParserService.ts      (New - HTML parsing service)
├── index.ts                  (Main API exports)
└── __tests__/
    └── ParserService.test.ts (Unit and integration tests)
parser-schema.json            (Root level schema configuration)
```

### Data Flow and Integration
**Input:** Raw HTML content from ScraperService (Story 1.3)
**Processing:** Apply CSS selectors from parser-schema.json to extract structured data
**Output:** Structured JSON object matching Vehicle interface
**Integration:** Will be consumed by main ingestion pipeline (Story 1.5)
**Database Integration:** Parsed data will be stored via VehicleRepository (Story 1.2)

### Technical Constraints and Configuration
**Node.js Runtime:** ~20.11.0 - Current LTS version [Source: architecture.md#tech-stack]
**TypeScript Integration:** Must follow monorepo TypeScript configuration
**Local-First:** All parsing operations run locally on user's machine [Source: architecture.md#platform-and-infrastructure-choice]
**Zero-Cost:** No external parsing services - pure Cheerio implementation
**Type Safety:** Must use shared types from packages/types [Source: architecture.md#key-developer-standards]

### Parser Schema Design Specifications
**Hybrid Schema Structure with Auto-Detection:**
```json
{
  "sites": {
    "otomoto": {
      "method": "json",
      "scriptSelector": "script#__NEXT_DATA__",
      "autoDetection": {
        "searchPageIndicator": "props.pageProps.urqlState",
        "detailPageIndicator": "props.pageProps.advert"
      },
      "pageTypes": {
        "search": {
          "basePath": "props.pageProps.urqlState",
          "dataPath": "data",
          "listPath": "advertSearch.edges",
          "fields": {
            "sourceId": "node.id",
            "sourceUrl": "node.url", 
            "sourceTitle": "node.title",
            "sourceCreatedAt": "node.createdAt"
          }
        },
        "detail": {
          "basePath": "props.pageProps.advert",
          "fields": {
            "sourceId": "id",
            "sourceTitle": "title",
            "sourceUrl": "url",
            "pricePln": "price.value",
            "priceCurrency": "price.currency",
            "sourceDescriptionHtml": "description",
            "sourceCreatedAt": "createdAt",
            "sellerName": "seller.name",
            "sellerId": "seller.id",
            "sellerType": "seller.type",
            "sellerLocation": "seller.location.address",
            "memberSince": "seller.featuresBadges[code=registration-date].label",
            "sourceParameters": "details",
            "sourceEquipment": "equipment",
            "sourcePhotos": "images.photos"
          }
        }
      }
    },
    "olx": {
      "method": "css",
      "pageTypes": {
        "detail": {
          "selectors": {
            "title": "h1[data-cy='ad_title']",
            "price": "[data-testid='ad-price-container']",
            "description": "[data-cy='ad_description']"
          }
        }
      }
    }
  }
}
```

**Parser Interface Design:**
```typescript
interface ParseResult {
  pageType: 'search' | 'detail';
  data: SearchResult[] | VehicleDetail;
}

// Method signature with optional validation
parseHtml(html: string, siteKey: string, expectedType?: 'search' | 'detail'): ParseResult
```

**Parsing Method Categories:**
- **JSON Method (Otomoto):** Extract from __NEXT_DATA__ with auto page type detection
- **CSS Method (OLX/Fallback):** Traditional CSS selector-based extraction
- **Auto-Detection:** Analyze JSON structure to determine search vs detail page
- **Validation:** Optional expected type validation for error prevention

### Integration with Future Stories
**Story 1.5 Integration:** Parsed data will be consumed by main ingestion pipeline
**Database Integration:** Structured data will be stored via VehicleRepository from Story 1.2
**AI Integration:** Parsed data will be used for AI analysis in Epic 2

## Testing

### Testing Standards
**Testing Framework:** Jest ~29.7.0 - Standard testing suite [Source: architecture.md#tech-stack]
**Testing Strategy:** Unit Tests for parsing logic and Integration Tests for schema application [Source: architecture.md#technical-assumptions]

### Testing Requirements for This Story
**Unit Tests:**
- ParserService initialization and schema loading
- JSON extraction from __NEXT_DATA__ script tags (Otomoto)
- CSS selector application and data extraction (OLX/fallback)
- Dynamic key handling in urqlState objects
- Data normalization and type conversion for both methods
- Error handling for invalid HTML, missing selectors, and malformed JSON

**Integration Tests:**
- End-to-end parsing with sample Otomoto HTML containing __NEXT_DATA__
- End-to-end parsing with sample OLX HTML using CSS selectors
- JSON path navigation and nested stringified JSON parsing
- Hybrid method selection based on site configuration
- Data quality validation against Vehicle interface
- Performance testing with large HTML documents and complex JSON structures

### Test File Locations
- Tests co-located with source files using `.test.ts` extensions
- Integration tests in `apps/api/src/__tests__/` directory
- Sample HTML fixtures with real Otomoto __NEXT_DATA__ content
- Sample OLX HTML fixtures for CSS selector testing
- Mock parser-schema.json for testing different configurations and methods

### Specific Test Scenarios
**Auto-Detection Tests:**
- Successful page type detection for Otomoto search pages (urqlState presence)
- Successful page type detection for Otomoto detail pages (advert presence)
- Error handling for unknown page types (neither search nor detail indicators)
- Validation of detected type against expected type parameter

**Two-Phase Parsing Tests:**
- Search page parsing: Extract vehicle URLs and basic metadata from advertSearch.edges
- Detail page parsing: Extract complete vehicle data from advert object
- Dynamic query hash key handling in urqlState for search pages
- Nested stringified JSON parsing in search page data properties

**Method-Specific Tests:**
- Successful JSON extraction from Otomoto __NEXT_DATA__ script for both page types
- Fallback to CSS selectors when JSON method fails
- Successful data extraction from OLX using CSS selectors
- Price conversion from PLN to EUR for both parsing methods
- Text normalization and HTML tag removal
- Image URL extraction from both JSON arrays and CSS selectors
- Error handling for malformed JSON, invalid selectors, and missing elements
- Schema validation and automatic method selection

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| Oct 5, 2025 | 1.0 | Initial story creation from Epic 1, Story 1.4 | Bob (SM) |
| Oct 5, 2025 | 1.1 | Updated to hybrid parsing approach with Otomoto JSON extraction from __NEXT_DATA__ | Bob (SM) |
| Oct 5, 2025 | 1.2 | Added two-phase scraping architecture with auto-detection for search vs detail pages | Bob (SM) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (James - Full Stack Developer)

### Debug Log References
- TypeScript compilation fixes: Fixed isolatedModules export issues and error handling
- Test suite development: Created comprehensive unit and integration tests (62 total tests)
- Schema validation: Implemented robust JSON schema loading and validation
- Price normalization: Handled complex PLN price formats with proper EUR conversion

### Completion Notes List
- ✅ Successfully implemented hybrid ParserService with JSON and CSS parsing methods
- ✅ Added Cheerio ~1.0.0 dependency (note: @types/cheerio not needed as Cheerio provides own types)
- ✅ Created comprehensive parser-schema.json with Otomoto JSON paths and OLX CSS selectors
- ✅ Implemented auto-detection for search vs detail pages using JSON structure analysis
- ✅ Added robust data normalization including price conversion, text cleaning, and URL validation
- ✅ Created 62 comprehensive tests covering unit and integration scenarios
- ✅ Added API endpoint demonstration (/api/parse) for service integration
- ✅ All acceptance criteria met and validated through automated testing

### File List
**Created Files:**
- `parser-schema.json` - Root level hybrid parsing configuration file
- `apps/api/src/services/ParserService.ts` - Main parser service implementation
- `apps/api/src/services/ParserService.test.ts` - Unit tests for ParserService
- `apps/api/src/__tests__/ParserService.integration.test.ts` - Integration tests

**Modified Files:**
- `apps/api/package.json` - Added Cheerio dependency
- `apps/api/src/index.ts` - Added ParserService export and demonstration endpoint

## QA Results
*Results from QA Agent review will be populated here after story completion*
