# <!-- Powered by BMAD™ Core -->

# Story 2.4: Market Value Score Service

## Status
Draft

## Story
**As a** user,
**I want** a backend service that can calculate the Market Value Score for each vehicle,
**so that** I can objectively see if it is a good deal based on comparable vehicles in the database.

## Acceptance Criteria
1. A `MarketValueService` is created in the backend (`apps/api/src/services/MarketValueService.ts`).
2. It has a function that takes a vehicle, finds comparable vehicles in the database, calculates a mileage-weighted average price, and returns the percentage difference.
3. The result is saved to the vehicle's record in the database (`marketValueScore` field).
4. The main analysis script (`apps/api/src/scripts/analyze.ts`) is updated to run this service **BEFORE** AI Priority Rating (so AI can use market value in its synthesis).

## Tasks / Subtasks
- [ ] Design and implement MarketValueService (AC: 1, 2)
  - [ ] Create `apps/api/src/services/MarketValueService.ts` file
  - [ ] Define comparison criteria for "comparable vehicles" (same make/model, ±3 years, ±50k km for 10+ year old vans)
  - [ ] Implement `calculateMarketValue(vehicle: Vehicle): Promise<string | null>` method
  - [ ] Query VehicleRepository to find comparable vehicles using Kysely
  - [ ] Calculate mileage-weighted average price (closer mileage = higher weight)
  - [ ] Apply mileage condition penalties/bonuses (high mileage >200k, low mileage <120k)
  - [ ] Return percentage difference as string (e.g., "-5%", "+10%", "market_avg")
  - [ ] Handle edge cases (no comparables found, insufficient data <3 vehicles)
  - [ ] Add comprehensive error handling for database queries
  - [ ] Export MarketValueService for use in analyze script
- [ ] Integrate MarketValueService with VehicleRepository (AC: 3)
  - [ ] Verify `updateVehicleAnalysis()` accepts `marketValueScore?: string` parameter (should already exist from Story 2.3)
  - [ ] Test updating `marketValueScore` field in database
  - [ ] Ensure marketValueScore is properly saved and retrieved
- [ ] Update analyze.ts script (AC: 4)
  - [ ] Import MarketValueService into `apps/api/src/scripts/analyze.ts`
  - [ ] Add MarketValueService invocation BEFORE AI Priority Rating (after Mechanic Report)
  - [ ] Call `calculateMarketValue()` for each vehicle in the batch
  - [ ] Update vehicle record with marketValueScore result
  - [ ] Add progress logging for market value calculation
  - [ ] Handle errors gracefully (continue processing remaining vehicles)
  - [ ] Update summary report to include market value calculation stats
- [ ] Create comprehensive test suite
  - [ ] Write unit tests for MarketValueService (`apps/api/src/services/MarketValueService.test.ts`)
  - [ ] Test finding comparable vehicles with sample data
  - [ ] Test average price calculation with various scenarios
  - [ ] Test percentage difference calculation (above, below, at market average)
  - [ ] Test edge case: no comparable vehicles found
  - [ ] Test edge case: insufficient data (< 3 comparables)
  - [ ] Test edge case: identical price to average
  - [ ] Mock VehicleRepository to avoid real database calls
  - [ ] Write integration tests for analyze.ts script with market value step
  - [ ] Verify marketValueScore is saved to database correctly
  - [ ] Test error handling for failed market value calculations

## Dev Notes

### Previous Story Insights
From Story 2.3 (AI Analysis Features), the following is now available:
- **Analysis Script Infrastructure**: `apps/api/src/scripts/analyze.ts` with batch processing, rate limiting, progress tracking, and error recovery
- **VehicleRepository Methods**:
  - `findVehiclesWithoutAnalysis()` - Query vehicles needing analysis
  - `updateVehicleAnalysis()` - Save analysis results (includes `marketValueScore?: string` field)
  - `findVehicleById()` - Retrieve specific vehicle
- **Service Pattern**: AIService demonstrates the service architecture pattern to follow
- **Error Handling Pattern**: Continue-on-failure strategy for batch processing
- **User Criteria Configuration**: `search-config.json` at workspace root (loaded via WorkspaceUtils)

**Key Architectural Pattern**: Follow the AIService structure - create a reusable service in `apps/api/src/services/` that can be imported by both the analyze script and future API routes.

### Architecture Context

**Service Architecture Pattern** [Source: architecture/backend-architecture.md]:
- **Service Layer**: Business logic in reusable services shared between API and scripts
- **Repository Pattern**: All database operations through `packages/db` repository layer
- **Separation of Concerns**: Each service has single responsibility, minimal dependencies

**Service Location** [Source: architecture/source-tree.md]:
```
apps/api/src/services/
├── ScraperService.ts
├── ParserService.ts
├── AIService.ts
└── MarketValueService.ts  # NEW - this story
```

**Analyze Script Location** [Source: architecture/source-tree.md]:
```
apps/api/src/scripts/
├── ingest.ts      # Data scraping
└── analyze.ts     # AI + Market Value analysis (to be updated)
```

### Data Models

**Vehicle Interface** [Source: architecture/data-models.md]:
The MarketValueService will populate the `marketValueScore` field:
```typescript
export interface Vehicle {
  // ... existing fields ...

  // Processed & Normalized Data (for querying comparables)
  title: string;           // Cleaned title
  pricePln: number;        // Price for comparison
  priceEur: number;
  year: number;            // For filtering comparables (±2 years)
  mileage: number;         // For filtering comparables (±20k km)

  // AI Generated Data
  marketValueScore: string | null;  // e.g., "-5%" or "+10%" or "market_avg" (to be populated)

  // ... other fields ...
}
```

**Market Value Score Format**:
- `"-X%"` - Vehicle is X% cheaper than market average (good deal)
- `"+X%"` - Vehicle is X% more expensive than market average (overpriced)
- `"market_avg"` - Vehicle is at market average (within ±2%)
- `null` - No comparable vehicles found or insufficient data

### Comparable Vehicle Criteria

**Target User Context**:
This implementation is optimized for **2005-2014 passenger vans** (Renault Trafic Passenger, Opel Vivaro Combi, Nissan Primastar, Ford Transit Tourneo, VW Transporter Kombi) - vehicles with seats for family/personal use, NOT commercial work vans.

**Key Market Research Findings**:
- EU average car mileage: **10,900-18,000 km/year**
- For passenger vans (family use): **~15,000 km/year** is expected
- Age is PRIMARY depreciation factor, but mileage matters significantly
- For 10+ year old vehicles: **Mileage becomes MORE important than age** (250k vs 150k is huge!)
- Depreciation: Year 1 (-20-30%), Years 2-10 (-10-20%/year), After 10 years (flattens)

**Definition of "Comparable Vehicle"** (MVP - Simple Algorithm):
A vehicle is considered comparable if it matches ALL of the following criteria:
1. **Same Make/Model**: Match on `sourceParameters.make` and `sourceParameters.model`
2. **Similar Year**: Within **±3 years** (e.g., for 2010 vehicle: 2007-2013)
   - Rationale: Age matters less for 10+ year vehicles; 2007 vs 2010 is minimal difference
3. **Similar Mileage**: Within **±50,000 km** (e.g., for 180k km vehicle: 130k-230k km)
   - Rationale: Wider range captures more comparables; we'll weight by mileage proximity
4. **Active Listings**: Not marked as deleted (`status != 'deleted'`)
5. **Exclude Self**: Don't include the vehicle being evaluated

**Minimum Sample Size**: Require at least **3 comparable vehicles** to calculate a meaningful average. If fewer than 3 comparables are found, return `null`.

### MarketValueService Implementation

**MVP Algorithm** (Simple & Focused on 10+ Year Old Vans):

```typescript
// apps/api/src/services/MarketValueService.ts
import { Vehicle } from '@car-finder/types';
import { VehicleRepository } from '@car-finder/db';

export class MarketValueService {
  private vehicleRepo: VehicleRepository;

  constructor(vehicleRepo: VehicleRepository) {
    this.vehicleRepo = vehicleRepo;
  }

  /**
   * Calculate market value score for a vehicle based on comparable listings
   * Optimized for 2005-2014 passenger vans with mileage-weighted averaging
   *
   * @param vehicle - Vehicle to evaluate
   * @returns Percentage difference string (e.g., "-5%", "+10%", "market_avg") or null if insufficient data
   */
  async calculateMarketValue(vehicle: Vehicle): Promise<string | null> {
    // 1. Find comparable vehicles (same make/model, ±3 years, ±50k km)
    const comparables = await this.findComparableVehicles(vehicle);

    // 2. Check minimum sample size
    if (comparables.length < 3) {
      return null; // Insufficient data
    }

    // 3. Calculate mileage-weighted average price
    const weightedAvg = this.calculateWeightedAverage(vehicle, comparables);

    // 4. Calculate percentage difference
    return this.formatPercentageDifference(vehicle.priceEur, weightedAvg);
  }

  private async findComparableVehicles(vehicle: Vehicle): Promise<Vehicle[]> {
    // Extract make/model from sourceParameters
    const make = vehicle.sourceParameters['make'];
    const model = vehicle.sourceParameters['model'];

    // Query VehicleRepository for comparables
    return await this.vehicleRepo.findComparableVehicles({
      source: vehicle.source,
      make,
      model,
      year: vehicle.year,
      mileage: vehicle.mileage,
      excludeId: vehicle.id,
    });
  }

  /**
   * Calculate mileage-weighted average price
   * Vehicles with closer mileage to target get higher weight
   * Apply mileage condition adjustments (high/low mileage bonuses/penalties)
   */
  private calculateWeightedAverage(target: Vehicle, comparables: Vehicle[]): number {
    let totalWeightedPrice = 0;
    let totalWeight = 0;

    for (const comp of comparables) {
      // 1. Calculate mileage proximity weight
      const mileageDiff = Math.abs(comp.mileage - target.mileage);
      const weight = 1 / (1 + mileageDiff / 10000); // Closer mileage = higher weight

      // 2. Apply mileage condition adjustments to price
      let adjustedPrice = comp.priceEur;

      // High mileage penalty
      if (comp.mileage > 200000) {
        adjustedPrice *= 0.90; // -10% for >200k km
      }
      if (comp.mileage > 250000) {
        adjustedPrice *= 0.90; // Additional -10% for >250k km (total -19%)
      }

      // Low mileage bonus (for old vans)
      const vehicleAge = new Date().getFullYear() - comp.year;
      if (comp.mileage < 120000 && vehicleAge > 10) {
        adjustedPrice *= 1.10; // +10% bonus for low-mileage old vans (golden find!)
      }

      // 3. Add to weighted sum
      totalWeightedPrice += adjustedPrice * weight;
      totalWeight += weight;
    }

    return totalWeightedPrice / totalWeight;
  }

  private formatPercentageDifference(vehiclePrice: number, avgPrice: number): string {
    const percentageDiff = ((vehiclePrice - avgPrice) / avgPrice) * 100;

    // Round to nearest integer
    const rounded = Math.round(percentageDiff);

    // Format
    if (Math.abs(rounded) < 2) {
      return "market_avg"; // Within ±2% is "at market"
    } else if (rounded > 0) {
      return `+${rounded}%`; // Overpriced
    } else {
      return `${rounded}%`; // Good deal (negative, already has minus sign)
    }
  }
}
```

**Algorithm Summary**:
1. Find comparables (±3 years, ±50k km)
2. Weight each comparable by mileage proximity: `weight = 1 / (1 + mileage_diff / 10000)`
3. Apply mileage condition adjustments:
   - >200k km: -10% penalty
   - >250k km: Additional -10% penalty (total -19%)
   - <120k km on 10+ year van: +10% bonus (rare low-mileage gem)
4. Calculate weighted average
5. Compare target price to weighted average

### VehicleRepository Integration

**Query for Comparable Vehicles**:
The VehicleRepository needs a new method to find comparable vehicles:
```typescript
// In packages/db/src/repositories/VehicleRepository.ts
async findComparableVehicles(params: {
  source: VehicleSource;
  make: string;
  model: string;
  year: number;
  mileage: number;
  excludeId: string;
}): Promise<Vehicle[]> {
  const { source, make, model, year, mileage, excludeId } = params;

  return await db
    .selectFrom('vehicles')
    .selectAll()
    .where('source', '=', source)
    .where('sourceParameters', 'like', `%"make":"${make}"%`) // JSON field search
    .where('sourceParameters', 'like', `%"model":"${model}"%`)
    .where('year', '>=', year - 3)  // ±3 years for older vehicles
    .where('year', '<=', year + 3)
    .where('mileage', '>=', mileage - 50000)  // ±50k km wider range
    .where('mileage', '<=', mileage + 50000)
    .where('status', '!=', 'deleted')
    .where('id', '!=', excludeId)
    .execute();
}
```

**Updating Market Value Score**:
The `updateVehicleAnalysis()` method already supports `marketValueScore?: string` (added in Story 2.3), so no changes needed there.

### Post-MVP: Smart Age+Mileage Algorithm

**NOTE**: The MVP algorithm above is optimized for 2005-2014 vehicles. This section documents a more sophisticated algorithm for future implementation that adapts to different vehicle age segments.

**Smart Algorithm** (Two-Tier Approach):

```typescript
/**
 * POST-MVP: Adaptive algorithm that changes weighting based on vehicle age
 * - For vehicles < 10 years: Age matters more (70% age, 30% mileage)
 * - For vehicles ≥ 10 years: Mileage matters more (40% age, 60% mileage)
 */
private calculateSmartWeightedAverage(target: Vehicle, comparables: Vehicle[]): number {
  const targetAge = new Date().getFullYear() - target.year;
  const isOldVehicle = targetAge >= 10;

  // Determine weighting strategy based on age
  const AGE_WEIGHT = isOldVehicle ? 0.40 : 0.70;
  const MILEAGE_WEIGHT = isOldVehicle ? 0.60 : 0.30;

  // Cap expected mileage for old vehicles
  const expectedKm = isOldVehicle
    ? Math.min(targetAge * 15000, 200000)  // Cap at 200k for old vans
    : targetAge * 15000;

  let totalWeightedPrice = 0;
  let totalWeight = 0;

  for (const comp of comparables) {
    const compAge = new Date().getFullYear() - comp.year;
    const compExpectedKm = isOldVehicle
      ? Math.min(compAge * 15000, 200000)
      : compAge * 15000;

    // 1. Calculate similarity score (age + mileage weighted)
    const ageDiff = Math.abs(target.year - comp.year);
    const mileageDiff = Math.abs(target.mileage - comp.mileage);

    const ageSimilarity = 1 - (ageDiff / 3);  // Normalized to ±3 years
    const mileageSimilarity = 1 - (mileageDiff / 50000);  // Normalized to ±50k km

    const similarityScore = (
      AGE_WEIGHT * ageSimilarity +
      MILEAGE_WEIGHT * mileageSimilarity
    );

    // 2. Apply mileage condition adjustments
    let adjustedPrice = comp.priceEur;

    // High mileage penalties
    if (comp.mileage > 200000) adjustedPrice *= 0.90;  // -10%
    if (comp.mileage > 250000) adjustedPrice *= 0.85;  // Additional -15% (total -23.5%)

    // Low mileage bonuses (age-dependent)
    if (comp.mileage < compExpectedKm * 0.6 && compAge > 10) {
      adjustedPrice *= 1.10;  // +10% for exceptionally low mileage on old van
    }

    // Suspiciously low mileage (odometer fraud risk)
    if (comp.mileage < 50000 && compAge > 10) {
      // No bonus - flag for verification
      adjustedPrice *= 1.0;
    }

    // 3. Weight by similarity score
    totalWeightedPrice += adjustedPrice * similarityScore;
    totalWeight += similarityScore;
  }

  return totalWeightedPrice / totalWeight;
}
```

**Key Improvements Over MVP**:
1. **Adaptive Weighting**: Changes age/mileage importance based on vehicle age
2. **Expected Mileage Cap**: For 15+ year vehicles, caps expected mileage at 200k (after that, condition matters more than km)
3. **Age-Relative Bonuses**: Low mileage bonus is calculated relative to expected mileage for age
4. **Fraud Detection**: Flags suspiciously low mileage on old vehicles
5. **Similarity-Based Weighting**: Combines age AND mileage similarity into unified score

**When to Implement**:
- After MVP validates with real data
- If user starts looking at newer vehicles (<10 years)
- If MVP algorithm shows systematic over/under-valuation

### Analyze Script Integration

**Updated Analysis Pipeline Order**:
The analyze.ts script currently executes:
1. Translation (description + features)
2. Data Sanity Check
3. Personal Fit Score
4. Virtual Mechanic's Report
5. Priority Rating

**NEW Pipeline Order** (with Market Value):
1. Translation (description + features)
2. Data Sanity Check
3. Personal Fit Score
4. Virtual Mechanic's Report
5. **Market Value Score** ← NEW STEP (before Priority Rating)
6. Priority Rating (synthesizes ALL data including market value)

**Rationale**: Market Value Score should be calculated BEFORE Priority Rating so the AI can consider market value when synthesizing the final priority rating and summary.

**Implementation in analyze.ts**:
```typescript
// Import MarketValueService
import { MarketValueService } from '../services/MarketValueService';

// Initialize service
const marketValueService = new MarketValueService(vehicleRepository);

// In the analysis loop, after Mechanic Report:
const marketValue = await marketValueService.calculateMarketValue(vehicle);
if (marketValue !== null) {
  await vehicleRepository.updateVehicleAnalysis(vehicle.id, {
    marketValueScore: marketValue,
  });
  console.log(`  💰 Market Value: ${marketValue}`);
} else {
  console.log(`  💰 Market Value: No comparables found`);
}

// Then run Priority Rating (which now has market value available)
```

### File Locations and Structure

**New Files** (to be created):
```
apps/api/src/services/
└── MarketValueService.ts              # NEW - Market value calculation service

apps/api/src/services/
└── MarketValueService.test.ts         # NEW - Unit tests for market value service
```

**Modified Files**:
```
apps/api/src/scripts/analyze.ts        # UPDATE - Add market value step to pipeline
packages/db/src/repositories/vehicleRepository.ts  # UPDATE - Add findComparableVehicles() method
```

### Error Handling Requirements

**Error Handling Strategy**:
1. **No Comparables Found**: Return `null` (not an error - vehicle is unique)
2. **Insufficient Data**: Return `null` if < 3 comparables (need minimum sample size)
3. **Database Errors**: Log error, continue processing remaining vehicles (don't fail batch)
4. **Invalid Data**: Handle missing/null price fields gracefully
5. **Division by Zero**: Handle edge case where avgPrice is 0

**Logging**:
- Log number of comparables found for each vehicle
- Log calculated average price and percentage difference
- Log when insufficient data prevents calculation
- Include vehicle ID in all log messages for debugging

### Technical Constraints

**TypeScript Requirements** [Source: architecture/tech-stack.md]:
- TypeScript ~5.5.0
- Explicit return types for all functions
- Strict null checks enabled
- No `any` types (use `unknown` if needed)

**Node.js Version** [Source: architecture/tech-stack.md]:
- Node.js ~20.11.0 (LTS)

**Dependencies**:
```json
{
  "dependencies": {
    "@car-finder/types": "workspace:*",
    "@car-finder/db": "workspace:*"
  }
}
```

### Naming Conventions

**Files** [Source: architecture/coding-standards.md]:
- Services: `PascalCase` - `MarketValueService.ts`
- Test files: `PascalCase.test.ts` - `MarketValueService.test.ts`

**Functions** [Source: architecture/coding-standards.md]:
- Functions: `camelCase` - `calculateMarketValue()`, `findComparableVehicles()`
- Private methods: `_camelCase` or `private` keyword

**Types** [Source: architecture/coding-standards.md]:
- Interfaces: `PascalCase` - `ComparableVehicleParams`
- Return type: `Promise<string | null>`

### Integration with Analysis Pipeline

**No Rate Limiting Needed**: Unlike AI operations, market value calculations are purely database queries with no external API calls, so no rate limiting is required.

**Performance Considerations**:
- Each market value calculation requires 1 database query (find comparables)
- Query uses indexed fields (year, mileage) for efficiency
- In-memory calculation (average, percentage) is instant
- No significant performance impact on batch processing

**Future Enhancements** (not part of this story):
- Cache comparable vehicle lists for similar vehicles
- Implement weighted averages based on recency (newer listings weighted higher)
- Add geographic filtering (if location data becomes available)
- Consider mileage-adjusted pricing models

## Testing

### Testing Standards

**Testing Framework** [Source: architecture/testing-strategy.md]:
- Jest ~29.7.0 for unit and integration tests
- Co-located `*.test.ts` files next to source files
- Focus on critical paths and complex logic

**Test Organization** [Source: architecture/testing-strategy.md]:
- Backend tests in `apps/api/src/services/__tests__/`
- Mock external dependencies (VehicleRepository) to avoid real database calls
- Use in-memory LibSQL for integration tests with analyze.ts script

### Testing Requirements for This Story

**MarketValueService Unit Tests** (`apps/api/src/services/MarketValueService.test.ts`):
- Test finding comparable vehicles with sample data
  - Mock VehicleRepository.findComparableVehicles() to return controlled data
  - Verify correct filtering criteria are applied
- Test average price calculation
  - Test with 3, 5, 10 comparable vehicles
  - Test with identical prices
  - Test with wide price range
- Test percentage difference calculation
  - Test vehicle cheaper than average (negative percentage)
  - Test vehicle more expensive than average (positive percentage)
  - Test vehicle at market average (within ±2%)
  - Test edge cases (0% difference, very large differences)
- Test edge cases
  - Test with no comparable vehicles found (return null)
  - Test with < 3 comparables (insufficient data, return null)
  - Test with missing/null price fields
  - Test with division by zero (avgPrice = 0)
- Test error handling
  - Test database query failures
  - Test invalid vehicle data
  - Verify errors are logged but don't throw exceptions

**VehicleRepository Tests** (`packages/db/src/__tests__/VehicleRepository.test.ts`):
- Test `findComparableVehicles()` query
  - Test filtering by source, make, model
  - Test year range filtering (±2 years)
  - Test mileage range filtering (±20k km)
  - Test exclusion of target vehicle (excludeId)
  - Test exclusion of deleted vehicles
  - Use in-memory LibSQL database with sample data

**Analyze Script Integration Tests** (`apps/api/src/scripts/__tests__/analyze.test.ts`):
- Test analyze.ts script includes market value step
  - Mock MarketValueService.calculateMarketValue()
  - Verify market value is calculated after mechanic report
  - Verify market value is calculated before priority rating
  - Verify database is updated with marketValueScore
- Test error handling in batch processing
  - Test script continues after market value calculation failure
  - Verify remaining vehicles are still processed
- Test summary report includes market value stats
  - Count vehicles with market value calculated
  - Count vehicles with no comparables found

### Test Coverage Goals

- Aim for >80% code coverage for MarketValueService methods
- 100% coverage for edge cases (no comparables, insufficient data)
- Test all error handling paths
- Mock database dependencies in unit tests

### Mock Implementation

**Mocking VehicleRepository in Tests**:
```typescript
const mockVehicleRepo = {
  findComparableVehicles: jest.fn().mockResolvedValue([
    { id: '1', priceEur: 10000, year: 2020, mileage: 100000, ... },
    { id: '2', priceEur: 11000, year: 2021, mileage: 95000, ... },
    { id: '3', priceEur: 9500, year: 2019, mileage: 110000, ... },
  ]),
};

const marketValueService = new MarketValueService(mockVehicleRepo as any);
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| Oct 9, 2025 | 1.0 | Initial story creation for Epic 2, Story 2.4 - Market Value Score Service | Bob (SM) |
| Oct 9, 2025 | 1.1 | Updated algorithm for 2005-2014 passenger vans: mileage-weighted averaging, ±3yr/±50km comparables, mileage condition penalties/bonuses. Moved market value calculation BEFORE AI Priority Rating. Added Post-MVP smart age-adaptive algorithm documentation. | Bob (SM) |
